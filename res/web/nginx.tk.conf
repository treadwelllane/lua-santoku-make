<%
  fs = require("santoku.fs")
  it = require("santoku.iter")
  arr = require("santoku.array")
  err = require("santoku.error")
  str = require("santoku.string")
  senv = require("santoku.env")
  -- server config with defaults
  port = server.port or "8080"
  port_ssl = server.port_ssl or "8443"
  domain = server.domain
  domain_base = server.domain_base
  ssl = server.ssl
  ssl_certificate = server.ssl_certificate
  ssl_certificate_key = server.ssl_certificate_key
  ssl_trusted_certificate = server.ssl_trusted_certificate
  redirect_base_domain = server.redirect_base_domain
  workers = server.workers
  resolver = server.resolver
  init = server.init
  init_worker = server.init_worker
  routes = server.routes
  shared_dicts = server.shared_dicts
  nginx_env_vars = server.nginx_env_vars
  nginx_no_cache = server.nginx_no_cache
  types_hash_max_size = server.types_hash_max_size
%>

<% return arr.concat(it.collect(it.map(function (var)
  return "env " .. var .. ";"
end, it.ivals(nginx_env_vars or {}))), "\n") %>

daemon off;
pid server.pid;
worker_processes <% return workers and tostring(workers) or "auto"  %>;

error_log <% return console_logs and "stderr" or "logs/error.log" %> info;

events {}

http {

  include <% return senv.var("OPENRESTY_DIR") %>/nginx/conf/mime.types;

  access_log <% return console_logs and "/dev/stdout" or "logs/access.log" %>;

  # Enable gzip compression
  gzip on;
  gzip_vary on;
  gzip_proxied any;
  gzip_comp_level 6;
  gzip_min_length 1000;
  gzip_types
    text/plain
    text/css
    text/xml
    text/javascript
    application/json
    application/javascript
    application/x-javascript
    application/xml
    application/xml+rss
    application/wasm
    image/svg+xml;

  lua_package_path "lua_modules/share/lua/5.1/?.lua;lua_modules/share/lua/5.1/?/init.lua;<% return senv.var('OPENRESTY_DIR') %>/lualib/?.lua;<% return senv.var('OPENRESTY_DIR') %>/lualib/?/init.lua;;";
  lua_package_cpath "lua_modules/lib/lua/5.1/?.so;<% return senv.var('OPENRESTY_DIR') %>/lualib/?.so;;";

  <% return arr.concat(it.collect(it.map(function (n, v)
    return arr.concat({ "lua_shared_dict", n, v, ";" }, " ")
  end, it.pairs(shared_dicts or {}))), "\n") %>

  <% push(environment ~= "test" and init) %>
  init_by_lua_file <% if showing() then
    local path = err.checknil(senv.searchpath(init, fs.join(dist_dir, "lua_modules/share/lua/5.1/?.lua")))
    return str.stripprefix(path, dist_dir .. "/")
  end %>;
  <% pop() push(environment == "test") %>
  init_by_lua_file init-test.lua;
  <% pop() %>

  <% push(environment ~= "test" and init_worker) %>
  init_worker_by_lua_file <% if showing() then
    local path = err.checknil(senv.searchpath(init_worker, fs.join(dist_dir, "lua_modules/share/lua/5.1/?.lua")))
    return str.stripprefix(path, dist_dir .. "/")
  end %>;
  <% pop() push(environment == "test") %>
  init_worker_by_lua_file init-worker-test.lua;
  <% pop() %>

  types_hash_max_size <% return types_hash_max_size or "2048" %>;
  types_hash_bucket_size <% return types_hash_max_size or "128" %>;

  <% push(resolver) %>
  resolver <% return resolver %>;
  <% pop() %>

  <% push(ssl_trusted_certificate) %>
  lua_ssl_trusted_certificate <% return ssl_trusted_certificate %>;
  <% pop() %>

  <% push(ssl) %>

  ssl_certificate <% return ssl_certificate %>;
  ssl_certificate_key <% return ssl_certificate_key %>;

  server {
    server_name _;
    listen <% return port %>;
    listen [::]:<% return port %>;
    return 301 https://$host$request_uri;
  }

  <% pop() push(redirect_base_domain and ssl) %>

  server {
    server_name <% return domain_base or "localhost" %>;
    listen <% return port_ssl %> ssl;
    listen [::]:<% return port_ssl %> ssl;
    return 301 https://<% return domain %>$request_uri;
  }

  <% pop() push(redirect_base_domain and not ssl) %>

  server {
    server_name <% return domain_base or "localhost" %>;
    listen <% return port %>;
    listen [::]:<% return port %>;
    return 301 http://<% return domain %>$request_uri;
  }

  <% pop() %>

  server {

    server_name <% return domain or "localhost" %>;

    <% push(ssl) %>
    listen <% return port_ssl %> ssl;
    listen [::]:<% return port_ssl %> ssl;
    <% pop() push(not ssl) %>
    listen <% return port %>;
    listen [::]:<% return port %>;
    <% pop() %>

    <% return arr.concat(it.collect(it.map(function (route)
      local method, path, mod = arr.spread(route)
      local file = err.checknil(senv.searchpath(mod, fs.join(dist_dir, "lua_modules/share/lua/5.1/?.lua")))
      if version_check then
        return str.interp(arr.concat({
          "location = %2 {",
          "  limit_except %1 { deny all; }",
          "  access_by_lua_block {",
          "    local client_version = ngx.var.http_x_client_version",
          "    if client_version and client_version ~= '%4' then",
          "      ngx.header['X-App-Version'] = '%4'",
          "      ngx.status = 409",
          "      ngx.header.content_type = 'text/plain'",
          "      ngx.say('Version mismatch')",
          "      return ngx.exit(409)",
          "    end",
          "  }",
          "  header_filter_by_lua_block { ngx.header['X-App-Version'] = '%4' }",
          "  content_by_lua_file %3;",
          "}"
        }, "\n"), { method, path, str.stripprefix(file, dist_dir .. "/"), version_check })
      else
        return str.interp(arr.concat({
          "location = %2 {",
          "  limit_except %1 { deny all; }",
          "  content_by_lua_file %3;",
          "}"
        }, "\n"), { method, path, str.stripprefix(file, dist_dir .. "/") })
      end
    end, it.ivals(routes or {}))), "\n\n") %>

    <% return arr.concat(it.collect(it.map(function (fp)
      return str.format(arr.concat({
        "location = %s {",
        "  limit_except GET { deny all; }",
        "  root public;",
        "  add_header Cache-Control 'private, max-age=0, must-revalidate';",
        "}"
      }, "\n"), fp)
    end, it.ivals(nginx_no_cache or {}))), "\n") %>

    location / {
      limit_except GET { deny all; }
      root public;
      try_files $uri $uri.html $uri/index.html =404;
      add_header Cache-Control 'private, max-age=0, must-revalidate';
    }

  }

}
